-- ch8 composer--display.setStatusBar( display.HiddenStatusBar )	--local gameGroup = display.newGroup()local composer = require( "composer" )local scene = composer.newScene()-- ch8 composerlocal physics = require "physics"-- ch8 pauselocal widget = require "widget" -- ch8 pauselocal backgroundlocal groundlocal charObjectlocal friedEgg	local scoreTextlocal eggTextlocal livesTextlocal shadelocal gameOverScreenlocal gameIsActive = falselocal startDroplocal gameLives = 3local gameScore = 0local eggCount = 0local mRand = math.randomlocal eggDensity = 1.0local eggShape = { -12,-13, 12,-13, 12,13, -12,13 }--egg:30x30local panShape = { 15,-13, 65,-13, 65,13, 15,13 }--ch8 savelocal highScoreTextlocal highScore--ch8 save--ch8 pauselocal pauseBtnlocal pauseBG--ch8 pause--ch8 composerlocal menuBtn--ch8 composer	system.setAccelerometerInterval( 100 )local isSimulator = "simulator" == system.getInfo("environment")	local eggCaughtSound = audio.loadSound( "friedEgg.wav" )local gameOverSound = audio.loadSound( "gameOver.wav" )--ch8 pauselocal btnSound = audio.loadSound( "btnSound.wav" )--ch8 pause--ch8 savelocal saveValue = function( strFilename, strValue )    -- will save specified value to specified file    local theFile = strFilename    local theValue = strValue        local path = system.pathForFile( theFile, system.DocumentsDirectory )        -- io.open opens a file at path. returns nil if no file found    local file = io.open( path, "w+" )    if file then       -- write game score to the text file       file:write( theValue )       io.close( file )    endendlocal loadValue = function( strFilename )    -- will load specified file, or create new file if it doesn't exist        local theFile = strFilename        local path = system.pathForFile( theFile, system.DocumentsDirectory )        -- io.open opens a file at path. returns nil if no file found    local file = io.open( path, "r" )    if file then       -- read all contents of file into a string       local contents = file:read( "*a" )       io.close( file )       return contents    else    -- create file b/c it doesn't exist yet       file = io.open( path, "w" )       file:write( "0" )       io.close( file )       return "0"    endend--ch8 save-- ch8 composerfunction scene:create ( event ) local gameGroup = self.view -- completely remove loadgame's view composer.removeScene( "loadgame" ) print( "\nmaingame: create event")endfunction scene:show( event)	local gameGroup = self.view-- ch8 composerlocal gameActivate = function()		gameIsActive = true		end	local moveChar = function(event)			charObject.x = display.contentCenterX - (display.contentCenterX * (event.yGravity*3))					if((charObject.x - charObject.width * 0.5) < 0) then			charObject.x = charObject.width * 0.5	elseif((charObject.x + charObject.width * 0.5) > display.contentWidth) then			charObject.x = display.contentWidth - charObject.width * 0.5	endend	local setScore = function( scoreNum )		local newScore = scoreNum		gameScore = newScore		if gameScore < 0 then gameScore = 0; end	scoreText.text = "Score: " .. gameScore 	scoreText.xScale = 0.5; scoreText.yScale = 0.5		scoreText.x = (scoreText.contentWidth * 0.5) + 15	scoreText.y = 15endlocal callGameOver = function()			audio.play( gameOverSound )		gameIsActive = false		physics.pause()   -- ch8 pause   pauseBtn.isVisible = false   pauseBtn.isActive = false   -- ch8 pause 	shade = display.newRect( 0, 0, 570, 320 )	shade:setFillColor( 0, 0, 0 )	shade.x = 240; shade.y = 160	shade.alpha = 0		gameOverScreen = display.newImageRect( "gameOver.png", 400, 300 )		local newScore = gameScore	setScore( newScore )		gameOverScreen.x = 240; gameOverScreen.y = 160	gameOverScreen.alpha = 0			gameGroup:insert( shade )		gameGroup:insert( gameOverScreen )			--TRANSITION GAME OVER ASSETS		transition.to( shade, { time=200, alpha=0.65 } )		transition.to( gameOverScreen, { time=500, alpha=1 } )		scoreText.isVisible = false	scoreText.text = "Score: " .. gameScore 	scoreText.xScale = 0.5; scoreText.yScale = 0.5	scoreText.x = 240; scoreText.y = 160	scoreText:toFront()	timer.performWithDelay( 0, function() scoreText.isVisible = true; end, 1 )   --ch8 save   if gameScore > highScore then      highScore = gameScore      local highScoreFilename = "highScore.data"      saveValue( highScoreFilename, tostring(highScore) )   end   highScoreText = display.newText( "Best Game Score: " .. tostring( highScore ), 0, 0, "Arial", 30 )   highScoreText:setFillColor( 255, 255, 255, 255 )     highScoreText.xScale = 0.5; highScoreText.yScale = 0.5     highScoreText.x = 240   highScoreText.y = 120   gameGroup:insert( highScoreText )    --ch8 save     --ch8 composer  local onMenuTouch = function( event )    if event.phase == "ended" then      audio.play( btnSound )      composer.gotoScene( "mainmenu", "fade", 500 )    end  end   local mbOptions = {     defaultFile="menubtn.png",     overFile = "menubtn-over.png",     onEvent=onMenuTouch,     width = 60,     height = 60,   }  menuBtn = widget.newButton(mbOptions)  menuBtn.x = 100; menuBtn.y = 260  gameGroup:insert( menuBtn )  -- ch8 composer  endlocal drawBackground = function()		background = display.newImageRect( "bg.png", 480, 320 )	background.x = 240; background.y = 160			gameGroup:insert( background )	ground = display.newImageRect( "grass.png", 480, 75 )	ground.x = 240; ground.y = 325	ground.myName = "ground"	local groundShape = { -285,-18, 285,-18, 285,18, -285,18 }	physics.addBody( ground, "static", { density=1.0, bounce=0, friction=0.5, shape=groundShape } )	gameGroup:insert( ground )	endlocal hud = function()			eggText = display.newText( "Caught: " .. eggCount, 0, 0, "Arial", 45 )	eggText:setTextColor( 1, 1, 1 )		eggText.xScale = 0.5; eggText.yScale = 0.5		eggText.x = (480 - (eggText.contentWidth * 0.5)) - 15	eggText.y = 305		gameGroup:insert( eggText )	livesText = display.newText( "Lives: " .. gameLives, 0, 0, "Arial", 45 )	livesText:setTextColor( 1, 1, 1 )	--> white	livesText.xScale = 0.5; livesText.yScale = 0.5		livesText.x = (480 - (livesText.contentWidth * 0.5)) - 15	livesText.y = 15		gameGroup:insert( livesText )	scoreText = display.newText( "Score: " .. gameScore, 0, 0, "Arial", 45 )	scoreText:setTextColor( 1, 1, 1 )	--> white	scoreText.xScale = 0.5; scoreText.yScale = 0.5		scoreText.x = (scoreText.contentWidth * 0.5) + 15	scoreText.y = 15		gameGroup:insert( scoreText )	--ch8 pause   local onPauseTouch = function( event )      if event.phase == "ended" and pauseBtn.isActive then         audio.play( btnSound )         -- Pause the game         if gameIsActive then            gameIsActive = false            physics.pause()            local function pauseGame()               timer.pause( startDrop )               print("timer has been paused")            end            timer.performWithDelay(1, pauseGame)            -- SHADE            if not shade then               shade = display.newRect( 0, 0, 570, 380 )               shade:setFillColor( 0, 0, 0, 255 )               shade.x = 240; shade.y = 160               gameGroup:insert( shade )             end            shade.alpha = 0.5            -- SHOW MENU BUTTON            if pauseBG then               pauseBG.isVisible = true               pauseBG.isActive = true               pauseBG:toFront()            end            pauseBtn:toFront()         else            if shade then               display.remove( shade )               shade = nil            end            if pauseBG then               pauseBG.isVisible = false               pauseBG.isActive = false            end            gameIsActive = true            physics.start()            local function resumeGame()               timer.resume( startDrop )               print("timer has been resumed")            end            timer.performWithDelay(1, resumeGame)         end --gameIsActive      end --if else   end --onPauseTouch   pbOptions = {     defaultFile="pausebtn.png",     overFile = "pausebtn-over.png",     --onPress=onPauseTouch,     onEvent=onPauseTouch,     width = 44,     height = 44,   }   pauseBtn = widget.newButton( pbOptions )   pauseBtn.x = 38; pauseBtn.y = 288   pauseBtn.isVisible = false   pauseBtn.isActive = false   gameGroup:insert( pauseBtn )   pauseBG = display.newImageRect( "pauseoverlay.png", 480, 320 )   pauseBG.x = 240; pauseBG.y = 160   pauseBG.isVisible = false   pauseBG.isActive = false   gameGroup:insert( pauseBG )   --ch8 pauseendlocal livesCount = function()	    gameLives = gameLives - 1  livesText.text = "Lives: " .. gameLives  livesText.xScale = 0.5; livesText.yScale = 0.5	--> for clear retina display text  livesText.x = (480 - (livesText.contentWidth * 0.5)) - 15  livesText.y = 15  print(gameLives .. " eggs left")          if gameLives < 1 then    			callGameOver()      endendlocal createChar = function()		local sheetData = { width=128, height=128, numFrames=4, sheetContentWidth=256, sheetContentHeight=256 }	local sheet = graphics.newImageSheet( "charSprite.png", sheetData )	local sequenceData = 		{			{ name="move", start=1, count=4, time=400 } 		}	charObject = display.newSprite( sheet, sequenceData )	charObject:setSequence("move")	charObject:play()	charObject.x = 240; charObject.y = 250	physics.addBody( charObject, "static", { density=1.0, bounce=0.4, friction=0.15, radius=20, shape=panShape} )	charObject.rotation = 0	charObject.isHit = false	charObject.myName = "character"		friedEgg = display.newImageRect( "friedEgg.png", 40, 23 )	friedEgg.alpha = 1.0	friedEgg.isVisible = false	gameGroup:insert( charObject )	gameGroup:insert( friedEgg )	endlocal onEggCollision = function( self, event )		if event.force > 1 and not self.isHit then		audio.play( eggCaughtSound )		self.isHit = true		print( "Egg destroyed!")		self.isVisible = false				friedEgg.x = self.x; friedEgg.y = self.y		friedEgg.alpha = 0		friedEgg.isVisible = true				local fadeEgg = function()			transition.to( friedEgg, { time=500, alpha=0 } )			end		transition.to( friedEgg, { time=50, alpha=1.0, onComplete=fadeEgg } )		self.parent:remove( self )		--egg is "self" here		self = nil		if event.other.myName == "character" then			eggCount = eggCount + 1			eggText.text = "Caught: " .. eggCount 			eggText.xScale = 0.5; eggText.yScale = 0.5	--> for clear retina display text			eggText.x = (480 - (eggText.contentWidth * 0.5)) - 15			eggText.y = 305			print("egg caught")						local newScore = gameScore + 500			setScore( newScore )		elseif event.other.myName == "ground" then						livesCount()			print("ground hit")					end					if gameLives < 1 then			timer.cancel( startDrop )			print("timer cancelled")		end	endendlocal eggDrop = function()		if gameIsActive == true then	local egg = display.newImageRect( "egg.png", 30, 30 )	egg.x = 240 + mRand( 120 ); egg.y = -100	egg.isHit = false		physics.addBody( egg, "dynamic",{ density=eggDensity, bounce=0, friction=0.5, shape=eggShape } )	egg.isFixedRotation = true	gameGroup:insert( egg )		egg.postCollision = onEggCollision	egg:addEventListener( "postCollision", egg )	endendlocal eggTimer = function()			startDrop = timer.performWithDelay( 1000, eggDrop, 0 )	-- 0: loop forever endlocal dragChar=function(event)    if isSimulator and charObject then        if event.phase == "began" then      moveX = event.x - charObject.x    elseif event.phase == "moved" then      charObject.x = event.x - moveX    end    print("moveX"..moveX)    if((charObject.x - charObject.width * 0.5) < 0) then      charObject.x = charObject.width * 0.5    elseif((charObject.x + charObject.width * 0.5) > display.contentWidth) then      charObject.x = display.contentWidth - charObject.width * 0.5    end      end  end --dragCharlocal gameStart = function()		physics.start( true )	physics.setGravity( 0, 9.8 )		drawBackground()	createChar()	eggTimer()	hud()	gameActivate()	Runtime:addEventListener("accelerometer", moveChar)	charObject:addEventListener("touch", dragChar)	--physics.setDrawMode( "hybrid" )  --ch8 save  local highScoreFilename = "highScore.data"  local loadedHighScore = loadValue( highScoreFilename )        highScore = tonumber(loadedHighScore)  --ch8 save    --ch8 pause   pauseBtn.isVisible = true   pauseBtn.isActive = true  --ch8 pauseendgameStart()end --showfunction scene:hide( event )  print( "maingame: hide event" )endfunction scene:destroy( event )  print( "destroying maingame's view" )end--ch8 composer	--return gameGroup--ch8 composer	--ch8 composer	-- "create" event is dispatched if scene's view does not existscene:addEventListener( "create", scene )-- "show" event is dispatched whenever scene transition has finishedscene:addEventListener( "show", scene )-- "hide" event is dispatched before next scene's transition beginsscene:addEventListener( "hide", scene )-- "destroy" event is dispatched before view is unloaded, which can bescene:addEventListener( "destroy", scene )return scene	--ch8 composer			